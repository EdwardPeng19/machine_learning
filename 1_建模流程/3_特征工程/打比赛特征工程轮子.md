# 1. 特征加法

## 1.1 时间特征（未聚合）

算未聚合前的一些特征

Groupby ID，然后根据时间特征算一些未聚合的值比如年、月、日、星期几、组内日期差等

```python
import numpy as np
import pandas as pd
from tqdm import tqdm, tqdm_notebook

def get_feats_time(data, group=None, feats=None, ts='ts'):
        """
        (1) 输入的data需要先根据group和ts进行排序, data.sort_values([group,ts])
        (2) 时间形式2018-07-25，必须为时间类型 pd.to_datetime('2018-07-25')
        时间的聚合特征同数值型
        与时间相关特征的特征衍生的非聚合特征
        :param data:
        :param group: "id"
        :param feats: numerical features name
        :param ts:
        :return
        """
        print('time continuous ...')
        data[ts + '_year'] = data[ts].apply(lambda x: x.year)
        data[ts + '_month'] = data[ts].apply(lambda x: x.month)
        data[ts + '_day'] = data[ts].apply(lambda x: x.day)
        data[ts + '_weekday'] = data[ts].apply(lambda x: x.weekday())
        data[ts + '_diff'] = data.groupby(group)[ts].diff().apply(lambda x: x.days).fillna(0)  ##########
        # transform是对一列进行操作
        data[ts + '_time_interval'] = data[ts].transform(lambda x: x.max() - x).apply(lambda x: x.days)
        if feats:  # 对时间特征可用数值特征平均编码
            print("ts_average_encoding ...")
            gr = data.groupby(ts)
            for i in tqdm_notebook(feats):
                data['ts_average_encoding_' + i] = gr[i].transform('mean')  # median

            print("feats diff ...")
            gr = data.groupby(group)
            for i in tqdm_notebook(feats):  # 数值特征也可以按时间顺序进行差分
                data['diff_' + i] = gr[i].diff().fillna(0)
        return data
```

## 1.2 类别特征（聚合）

算一些聚合特征

```python
from sklearn.feature_extraction import text
from tqdm import tqdm, tqdm_notebook


class CategoryFeature(object):
    @staticmethod
    def get_feats_vectors(X, vectorizer='TfidfVectorizer', tokenizer=None, ngram_range=(1, 1), max_features=None):
        """
        :param X: pd.Series
        :param vectorizer: 'TfidfVectorizer' or 'CountVectorizer'
        :param tokenizer: lambda x: x.split(',')
        :param ngram_range:
        :param max_features:
        :return:
        """
        vectorizer = text.__getattribute__(vectorizer)
        vectorizer = vectorizer(lowercase=False, tokenizer=tokenizer, ngram_range=ngram_range,
                                max_features=max_features)
        vectorizer.fit(X)
        return vectorizer

    @staticmethod
    def get_feats_desc(data, group='ID', feats=None):
        _gr = data.groupby(group)
        for col_name in tqdm_notebook(feats):
            funcs = ['count', 'nunique', 'max', 'min']
            _columns = {i: col_name + '_' + i for i in funcs}
            gr = _gr[col_name]

            def _func():
                df = gr.agg(funcs).reset_index()
                df[col_name + '_' + 'max_min'] = df['max'] - df['min']
                df[col_name + '_' + 'category_density'] = df['nunique'] / df['count']
                df[col_name + '_' + 'mode'] = gr.apply(lambda x: x.value_counts().index[0]).values
                return df.rename(columns=_columns)

            if col_name == feats[0]:
                df = _func()
            else:
                df = df.merge(_func(), 'left', group)
        return df.fillna(0)

```

## 1.3 数值型特征（聚合）

算一些聚合特征

```python
import numpy as np
import pandas as pd
from tqdm import tqdm, tqdm_notebook

def get_feats_desc(data, group='ID', feats=['feature1', ]):
        """
        data未聚合
        时间特征差分后当数值型特征
        
        """
        print("There are %s features..."%str(len(feats)))

        for col_name in tqdm_notebook(feats, desc='get_feature_desc'):

#             _columns = {i: col_name + '_' + i for i in ['count', 'mean', 'std', 'var', 'min', 'q1', 'median', 'q3', 'max']}
            gr = data.groupby(group)[col_name]

            def _func():
                q1_func = lambda x : np.quantile(x, q=0.25)
                q3_func = lambda x : np.quantile(x, q=0.75)
                get_max_min = lambda x : np.max(x) - np.min(x)
                get_q3_q1 = lambda x : np.quantile(x, q=0.75) - np.quantile(x, q=0.25)
                # (new_feature_name, operation)
                df = gr.agg([(col_name+'_'+'count','count'), (col_name+'_'+'mean','mean'), (col_name+'_'+'std','std'),\
                             (col_name+'_'+'var','var'), (col_name+'_'+'min','min'), (col_name+'_'+'max','max'),\
                             (col_name+'_'+'median','median'), (col_name+'_'+'q1',q1_func), (col_name+'_'+'q3',q3_func), \
                             (col_name+'_'+'max_min',get_max_min), (col_name+'_'+'q3_q1',get_q3_q1), (col_name+'_'+'kurt',pd.Series.kurt), \
                             (col_name+'_'+'skew',pd.Series.skew), (col_name+'_'+'sem',pd.Series.sem), (col_name+'_'+'sum',np.sum)]).reset_index()         
                return df
            if col_name == feats[0]:
                df = _func()
            else:
                df = df.merge(_func(), 'left', group).fillna(0)
        return df
```




# 2. 特征减法





# 3. 效果验证